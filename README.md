# snakeAI
## 功能概要 ##
- 智能贪吃蛇能够选择通过键盘输入进行游戏，让玩家通过自己的技术不断获取食物拿到高分
- 能够选择自动游戏，让程序自动的进行游戏，一般情况下，程序只能够充到仅留下2到3个小方格空间取决于场地大小
- 手动/自动的切换时通过初始化Snakegame对象时传入参数来决定的，1：手动模式；2：自动模式

## 设计之前考虑的一些问题及解决方法 ##


1.  问题一：如何让蛇找到吃食物的最短路径？

	使用广度优先搜索算法（BFS）
2.  鲁莽的去吃食物，会将自己陷入困境，怎么办？怎样的情况对自己来说是安全的？

	派一支“哨兵”去探路，确认吃完后安全再走。最安全的地方无疑是蛇尾，如果我吃完食物后能找到蛇尾，我就认为是安全的。

3. 既然吃食物不安全，那我该怎么办？

	边向蛇尾走边不断地派出“哨兵”，注意在闲逛期间尽量填充经过的空间。不要留下太多零碎的空间。

整理上述问题，设计如下流程：

可以简要证明：蛇是永远不死的。因为一开始场地空旷，蛇头到蛇尾必有路，随后蛇只会处于两种状态：走向食物或者走向蛇尾。走向食物的前提是吃到食物后，到蛇尾有路，那么当前状态到蛇尾必有路。走向蛇尾到蛇尾显然有路。故蛇头到蛇尾始终有路，那么蛇必然不会死。

## 主要算法 ##
### BFS算法 ###
DFS算法是贯穿整个程序的主要算法，整个场地用一个二维矩阵来存储，里面的数据分别代表不同含义：0:目标、-1：蛇身、0~UNDEFINED：不连通区域。DFS算法从0出发，访问所有与0处于同一个支的点，并用该点到0的距离作为该点数据填充项。

优化：采用python中高速容器数据结构deque实现队列，入队出队都接近O(1)

下面两张图是示例：


### 寻路策略 ###
由于整个图像是动态变化的，因此每次走一步以后，就重新使用DFS算法计算整个图像。

对于食物的寻路策略是，DFS算法填充图矩阵后，从蛇头出发选择标号最小的点，走一步。然后重新使用DFS算法，直到吃到食物。

而对于蛇尾的策略则大不相同，因为走向蛇尾期间要尽可能多的填充空间，因此要使用尽可能长的路径来到达蛇尾。依旧需要每走一步执行一次DFS算法，另外只有当前位置到食物没有安全路径的时候，我们才选择走向蛇尾。


**寻路策略 – 到蛇尾寻路的优化**

能够填充足够多的空间，对算法的效率影响极大，这样不但能够减少最后无法到达的小格的个数，还能大大减少蛇走的步数。

之前我使用的是和到食物寻路的相反的策略--每一步选择标号最大的结点。下面这种情况下表现不佳：

理想情况应该是：

优化过程也是模拟一只蛇过去“探路”，考虑到效率问题，让模拟的蛇前进两步即可。图中从-1出发有两种选择，上边的4和右边的4，从上边的4出发，每次取最大编号，前进两步后第三步的选择是“4”，而从左边出发第三次的选择是“2”。因此选择走上边的4。以此类推，可以获得一个不错的结果，实验表明大多数情况下可以获得最优解，即在追随蛇尾时填充所有可能填充的空间。






